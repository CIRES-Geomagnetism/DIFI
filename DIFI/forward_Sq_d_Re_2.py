# Autogenerated with SMOP 0.29
import datetime, warnings
import numpy as np
from typing import Union
print("it must just be getting hung up on imports")
from DIFI import jd2000_dt
from DIFI import getmut
from DIFI import gg2gm_2010
from DIFI import design_SHA_Sq_i_Re_v2
from DIFI import design_SHA_Sq_e_Re_v2
from get_f107_index_all import load_swarm_DIFI8

def forward_Sq_d_Re_v2(r, theta, phi, t, f107, s, mem=5e8):
	"""
	Python translation of MATLAB forward_Sq_d_Re_v2
	"""

	# reference radius [km]
	a = 6371.2
	rho = np.array(r, ndmin=1) / a
	rho_Sq = (a + s['h']) / a

	# extract from structure
	nmax = s['nmax']
	mmax = s['mmax']
	p_vec = s['p_vec']
	s_vec = s['s_vec']
	theta_NGP = s['theta_NGP']
	phi_NGP = s['phi_NGP']
	max_size = max(
		np.array(
			(
				[np.size(r)],
				[np.size(theta)],
				[np.size(phi)],
				[np.size(t)],
				[np.size(f107)]
			)
		)
	)
	if np.isscalar(r) or len(r) == 1:
		r = np.multiply(r, np.ones(max_size))

	if np.isscalar(theta) or len(theta) == 1:
		theta = np.multiply(theta, np.ones(max_size))

	if np.isscalar(phi) or len(phi) == 1:
		phi = np.multiply(phi, np.ones(max_size))

	if np.isscalar(t) or len(t) == 1:
		t = np.multiply(t, np.ones(max_size))

	if np.isscalar(f107) or len(f107) == 1:
		f107 = np.multiply(f107, np.ones(max_size))

	if (
		np.size(t) != np.size(r)
		or np.size(t) != np.size(theta)
		or np.size(t) != np.size(phi)
		or np.size(t) != np.size(f107)
	):
		print(
			np.size(t),
			np.size(r),
			np.size(theta),
			np.size(phi),
			np.size(f107),
		)
	# convert inputs to column vectors
	# rho = np.atleast_1d(rho).astype(float).reshape(-1, 1)
	# theta = np.atleast_1d(theta).astype(float).reshape(-1, 1)
	# phi = np.atleast_1d(phi).astype(float).reshape(-1, 1)
	# # t = np.atleast_1d(t).reshape(-1, 1)
	# f107 = np.atleast_1d(f107).reshape(-1, 1)

	# # expand scalars
	# max_length = max(len(rho), len(theta), len(phi), len(t), len(f107))
	# def expand(x): return np.full((max_length, 1), x) if x.size == 1 else x
	# rho, theta, phi, t, f107 = map(expand, [rho, theta, phi, t, f107])

	# check shapes
	# if not (rho.shape == theta.shape
	# must be of equal size (or scalars)")

	# ---- time handling ----
	# MATLAB datevec: here t assumed to be datetime or jd values
	# Stub: replace jd2000 + getmut with your implementations
	t_1 = [
			datetime.timedelta(int(t_iter), (t_iter - int(t_iter)) * 3600)
			+ datetime.datetime(2000, 1, 1)
			for t_iter in t
		]

	year = [t_iter.year for t_iter in t_1]
	ndays = np.zeros(np.size(year))
	for i in range(len(year)):
		ndays[i] = (
			datetime.datetime(year[i]+1, 1, 1)
			- datetime.datetime(year[i], 1, 1)
		).days
	# list comprehension must be converted to ndarray
	t_season = np.array(
		[
			(t[i] - jd2000_dt.jd2000_dt(year[i], 1, 1, 0)) / ndays[i]
			for i in range(len(ndays))
		]
	)
	# not inlcuded in HDGM version
	t_season = t_season.flatten()
	t_mut = getmut.getmut(t, s['theta_NGP'], s['phi_NGP'])

	# ---- coefficients ----
	N_nm = mmax * (mmax + 2) + (nmax - mmax) * (2 * mmax + 1)
	N_sp = len(p_vec) * len(s_vec)
	N_coeff_nm = 2 * N_nm * N_sp

	m_e_d_Re = s['m_e_d_Re'].reshape(N_coeff_nm, 1)
	m_i_d_Re = s['m_i_d_Re'].reshape(N_coeff_nm, 1)

	N_data = len(rho)
	chunk_size = int(mem // (8 * 3 * 2 * N_coeff_nm))

	# preallocate
	B_r_1_tmp = np.zeros((N_data, 1))
	B_theta_1_tmp = np.zeros((N_data, 1))
	B_phi_1_tmp = np.zeros((N_data, 1))

	B_r_2_tmp = np.zeros((N_data, 1))
	B_theta_2_tmp = np.zeros((N_data, 1))
	B_phi_2_tmp = np.zeros((N_data, 1))

	# ---- CASE 1: above Sq currents ----
	# print("rho check",rho, rho_Sq)
	# if np.min(rho) > rho_Sq:
	if True:
		f = np.zeros(N_nm)
		i1 = 0
		for n in range(1, nmax + 1):
			nr = min(2 * n + 1, 2 * mmax + 1)
			f[i1:i1 + nr] = -n / (n + 1) * rho_Sq ** (2 * n + 1)
			i1 += nr
		f = np.tile(f, (2 * N_sp, 1)).flatten()
		m_e_d_Re_C = m_e_d_Re.flatten() * f

		for k in range(0, N_data, chunk_size):
			index = slice(k, min(k + chunk_size, N_data))

			theta_d, phi_d, R = gg2gm(theta[index], phi[index],
										 1, None, None,
										 [theta_NGP, phi_NGP])

			A_r_i_d, A_theta_i_dd, A_phi_i_dd = design_SHA_Sq_i_Re_v2.design_SHA_Sq_i_Re_v2(
				rho[index], theta_d, phi_d,
				t_season[index], t_mut[index],
				nmax, mmax, p_vec, s_vec
			)

			r11, r21 = R[:, 0, 0], R[:, 1, 0]
			r12, r22 = R[:, 0, 1], R[:, 1, 1]

			A_theta_i_d = r11[:, None] * A_theta_i_dd + r21[:, None] * A_phi_i_dd
			A_phi_i_d = r12[:, None] * A_theta_i_dd + r22[:, None] * A_phi_i_dd

			B_r_1_tmp[index] = A_r_i_d @ m_e_d_Re_C
			B_theta_1_tmp[index] = A_theta_i_d @ m_e_d_Re_C
			B_phi_1_tmp[index] = A_phi_i_d @ m_e_d_Re_C

			B_r_2_tmp[index] = A_r_i_d @ m_i_d_Re
			B_theta_2_tmp[index] = A_theta_i_d @ m_i_d_Re
			B_phi_2_tmp[index] = A_phi_i_d @ m_i_d_Re

	# return stacked vectors
	B_1 = np.hstack([B_r_1_tmp, B_theta_1_tmp, B_phi_1_tmp])
	B_2 = np.hstack([B_r_2_tmp, B_theta_2_tmp, B_phi_2_tmp])
	return B_1, B_2

def gg2gm(theta_gg, phi_gg, *args):
	"""
	Transformation between geographic and geomagnetic (dipole) coordinates and components.
	
	Usage (mirrors MATLAB):
	theta_gm, phi_gm = gg2gm(theta_gg, phi_gg)
	theta_gm, phi_gm = gg2gm(theta_gg, phi_gg, i_trans)
	theta, phi, B_theta, B_phi = gg2gm(theta_in, phi_in, i_trans, B_theta, B_phi)
	theta, phi, B_theta, B_phi = gg2gm(theta_in, phi_in, i_trans, B_theta, B_phi, [theta_b, phi_b])
	theta, phi, B_theta, B_phi = gg2gm(theta_in, phi_in, i_trans, B_theta, B_phi, [g10, g11, h11])
	theta, phi, R = gg2gm(theta_in, phi_in, i_trans=+1)   # R is 2x2 rotation matrix
	"""

	rad = np.pi / 180.0
	theta_gg = np.atleast_1d(theta_gg).astype(float)
	phi_gg = np.atleast_1d(phi_gg).astype(float)

	# Defaults
	i_trans = +1
	if len(args) >= 1:
		i_trans = args[0]
	if abs(i_trans) != 1:
		raise ValueError("i_trans should be +1 or -1")

	# Pole definition
	if len(args) >= 3 and args[2] is not None:
		tmp = np.asarray(args[2]).flatten()
		if len(tmp) == 2:  # [theta_b, phi_b]
			theta_b, phi_b = tmp
		elif len(tmp) == 3:  # [g10, g11, h11]
			g10, g11, h11 = tmp
			phi_b = np.degrees(np.arctan2(-h11, -g11))
			theta_b = np.degrees(np.arctan2(np.sqrt(g11**2 + h11**2), -g10))
		else:
			raise ValueError("Argument 6 must be [theta_b, phi_b] or [g10, g11, h11]")
	else:
		theta_b, phi_b = 9.92, 287.78  # epoch 2010.0 (IGRF-11)

	s_p_b, c_p_b = np.sin(phi_b*rad), np.cos(phi_b*rad)
	c_t_b, s_t_b = np.cos(theta_b*rad), np.sin(theta_b*rad)

	A = np.array([
		[ c_t_b*c_p_b,  c_t_b*s_p_b, -s_t_b],
		[       -s_p_b,        c_p_b,     0],
		[ s_t_b*c_p_b,  s_t_b*s_p_b,  c_t_b]
	])
	if i_trans == -1:
		A = A.T

	# GEO spherical -> cartesian
	c_t, s_t = np.cos(theta_gg*rad), np.sin(theta_gg*rad)
	c_p, s_p = np.cos(phi_gg*rad),   np.sin(phi_gg*rad)

	z = c_t
	x = s_t * c_p
	y = s_t * s_p

	x_gm = A[0,0]*x + A[0,1]*y + A[0,2]*z
	y_gm = A[1,0]*x + A[1,1]*y + A[1,2]*z
	z_gm = A[2,0]*x + A[2,1]*y + A[2,2]*z

	theta_gm = 90 - np.degrees(np.arctan2(z_gm, np.sqrt(x_gm**2 + y_gm**2)))
	phi_gm = np.mod(np.degrees(np.arctan2(y_gm, x_gm)), 360.0)

	outputs = [theta_gm, phi_gm]

	# Handle B_theta, B_phi transformation if provided
	if len(args) >= 3 and args[1] is not None:
		B_theta = np.asarray(args[1])
		B_phi   = np.asarray(args[2])

		BE = B_theta * c_t
		Bx = BE * c_p - B_phi * s_p
		By = BE * s_p + B_phi * c_p
		Bz = -B_theta * s_t

		Bx_gm = A[0,0]*Bx + A[0,1]*By + A[0,2]*Bz
		By_gm = A[1,0]*Bx + A[1,1]*By + A[1,2]*Bz
		Bz_gm = A[2,0]*Bx + A[2,1]*By + A[2,2]*Bz

		c_t2, s_t2 = np.cos(theta_gm*rad), np.sin(theta_gm*rad)
		c_p2, s_p2 = np.cos(phi_gm*rad), np.sin(phi_gm*rad)

		BE2 = Bx_gm * c_p2 + By_gm * s_p2
		B_theta_out = BE2 * c_t2 - Bz_gm * s_t2
		B_phi_out   = By_gm * c_p2 - Bx_gm * s_p2

		outputs += [B_theta_out, B_phi_out]

	# Handle R matrix if nargout == 3 in MATLAB
	if len(outputs) == 2 and i_trans == 1:
		# Build R as in MATLAB
		c_t, s_t = np.cos(theta_gg*rad), np.sin(theta_gg*rad)
		c_p, s_p = np.cos(phi_gg*rad),   np.sin(phi_gg*rad)
		N = len(c_p)

		# GEO spherical -> cartesian
		R1 = np.zeros((N, 3, 3))
		R1[:,0,:] = np.stack([s_t*c_p, c_t*c_p, -s_p], axis=-1)
		R1[:,1,:] = np.stack([s_t*s_p, c_t*s_p,  c_p], axis=-1)
		R1[:,2,:] = np.stack([c_t,     -s_t,    np.zeros(N)], axis=-1)

		# MAG cartesian -> spherical
		c_tg, s_tg = np.cos(theta_gm*rad), np.sin(theta_gm*rad)
		c_pg, s_pg = np.cos(phi_gm*rad),   np.sin(phi_gm*rad)

		R2 = np.zeros((N, 3, 3))
		R2[:,0,:] = np.stack([s_tg*c_pg, s_tg*s_pg, c_tg], axis=-1)
		R2[:,1,:] = np.stack([c_tg*c_pg, c_tg*s_pg, -s_tg], axis=-1)
		R2[:,2,:] = np.stack([-s_pg,     c_pg,     np.zeros(N)], axis=-1)

		# MAG->GEO matrix
		R_mag_geo = np.zeros((N, 3, 3))
		R_mag_geo[:,0,:] = np.array([c_t_b*c_p_b, c_t_b*s_p_b, -s_t_b])
		R_mag_geo[:,1,:] = np.array([-s_p_b,      c_p_b,       0])
		R_mag_geo[:,2,:] = np.array([s_t_b*c_p_b, s_t_b*s_p_b, c_t_b])

		R_tmp = np.einsum('nij,njk->nik', R_mag_geo, R1)
		R3 = np.einsum('nij,njk->nik', R2, R_tmp)
		outputs.append(R3[:,1:3,1:3])  # only horizontal 2x2 block

	return tuple(outputs)


def parse_geomagnetic_data(filepath):
	# Define column labels
	keys = [
		"year", "month", "day", "hour", "min", "sec",
		"r", "theta", "phi", "h", "lat", "lon", "F10.7",
		"B_r", "B_theta", "B_phi", "X", "Y", "Z"
	]
	print("where am I at, this is running right?")
	data = []
	with open(filepath, 'r') as f:
		for line in f:
			# Split the line into values and convert to floats
			values = list(map(float, line.strip().split()))
			# Create a dictionary for each row
			entry = dict(zip(keys, values))
			data.append(entry)
	
	return data

data = parse_geomagnetic_data("DIFI/Arnaud_DIFI_update_files/test_values_DIFI8_v1_20250928.txt")
print(data[0].keys())
theta, phi, year, month, day, hour, minute, r, f107, Br, Btheta, Bphi, BX, BY, BZ  = [],[],[],[],[],[],[],[],[],[],[],[],[],[],[]
for i in range(0,len(data)):
	theta.append(data[i]['theta'])
	phi.append(data[i]['phi'])
	year.append(data[i]['year'])
	month.append(data[i]['month'])
	day.append(data[i]['day'])
	hour.append(data[i]['hour'])
	minute.append(data[i]['min'])
	r.append(data[i]['r'])
	f107.append(data[i]['F10.7'])
	Br.append(data[i]['B_r'])
	Btheta.append(data[i]['B_theta'])
	Bphi.append(data[i]['B_phi'])
	BX.append(data[i]['X'])
	BY.append(data[i]['Y'])
	BZ.append(data[i]['Z'])


t = jd2000_dt.jd2000_dt(year, month, day, hour, minute)
swarm_data = load_swarm_DIFI8()
out_calc = forward_Sq_d_Re_v2(r, theta, phi, t, f107, swarm_data)
print(out_calc[0][0], Br[0], Btheta[0], Bphi[0], BX[0], BY[0], BZ[0])
print(np.shape(out_calc))
