# Autogenerated with SMOP 0.29
import datetime
import jd2000_dt
import getmut
import gg2gm_2010
import numpy as np
import design_SHA_Sq_i_Re_v2
import design_SHA_Sq_e_Re_v2
# 

    
def forward_Sq_d_Re(r,theta,phi,t,f107,s):
    # [B_1,B_2] = forward_Sq_d_Re(r,theta,phi,t,f107,s)
    
    # Calculate the primary (1) and induced (2) Sq magnetic field from a model
    # in DIPOLE coordinates (parameterization of Sabaka et al., 2002).
    # The output values B_1 and B_2 are in SPHERICAL Coordinates
    
    # Inputs:   
#       r(:)                    radius [km]
#       theta(:), phi(:)        geographic co-latitude, longitude [deg]
#       t(:)                    time [MJD2000]
#       f107(:)                 F10.7 index
#       s is a structure with the following elements                       
#           m_e_d_Re(:,:)           primary Sq model (REAL coefficients)
#           m_i_d_Re(:,:)           secondary Sq model (REAL coefficients)
#           nmax, mmax              max degree and order in dipole coord.
#           p_vec(:)                diurnal wavenumbers
#           s_vec(:)                seasonal wavenumbers
#           theta_NGP               co-latitude of N. Geomagnetic Pole [deg]
#           phi_NGP                 longitude of N. Geomagnetic Pole [deg]
#           h                       altitude of Sq currents [km]
#           N                       Woldf ratio of the F10.7 dependence
    
    # Dependendies :
# - "gg2gm", "jd2000", "getmut"
# - "design_SHA_Sq_i_Re" and "design_SHA_Sq_e_Re"
    
    # A. Chulliat, 2016-09-22
# (from an earlier version dated 2011-04-23, with inputs from N. Olsen)

    # Translated to Python by A. Woods 2018-1-1
    
    # calculate radii in units of reference radius
    a=6371.2
    rho=r / a
    rho_Sq=(a + s['h']) / a
    # convert to matrix if input parameter is scalar
    max_size=max(np.array(([np.size(rho)],[np.size(theta)],[np.size(phi)],[np.size(t)])))
    if np.isscalar(rho) or len(rho) == 1:
        rho=np.multiply(rho,np.ones(max_size))
    
    if np.isscalar(theta) or len(theta) == 1:
        theta=np.multiply(theta,np.ones(max_size))
    
    if np.isscalar(phi) or len(phi) == 1:
        phi=np.multiply(phi,np.ones(max_size))
    
    if np.isscalar(t) or len(t) == 1:
        t=np.multiply(t,np.ones(max_size))
    
    if np.isscalar(f107) or len(f107) == 1:
        f107=np.multiply(f107,np.ones(max_size))

    if np.size(t) != np.size(rho) or np.size(t) != np.size(theta) or np.size(t) != np.size(phi) or np.size(t) != np.size(f107):
        print(np.size(t), np.size(rho), np.size(theta), np.size(phi), np.size(f107))
        raise Exception(r"Variables must be of equal size (or scalars)")
    
    # calculate time in year (season) and MUT
    t_1=[datetime.timedelta(int(t_iter), (t_iter-int(t_iter))*3600) + datetime.datetime(2000,1,1) for t_iter in t]
    year=[t_iter.year for t_iter in t_1]
    ndays=np.zeros(np.size(year))
    for i in xrange(len(year)):
        ndays[i]=(datetime.datetime(year[i]+1,1,1) - datetime.datetime(year[i],1,1)).days
    t_season=np.array([(t[i] - jd2000_dt.jd2000_dt(year[i],1,1,0)) / ndays[i] for i in xrange(len(ndays))]) #list comprehension must be converted to ndarray
    t_season = np.squeeze(t_season) #not inlcuded in HDGM version
    t_mut=getmut.getmut(t,s['theta_NGP'],s['phi_NGP'])
    # calculate dipolar coordinates + matrix R

    theta_d,phi_d,R=gg2gm_2010.gg2gm_2010(theta,phi,get_R=True)
    
    # calculate number of coefficients and data
    N_nm=s['mmax']*(s['mmax'] + 2) + (s['nmax'] - s['mmax'])*(2*s['mmax'] + 1)
    N_sp=np.size(s['p_vec'])*np.size(s['s_vec'])
    N_coeff_nm=2*N_nm*N_sp
    if np.size(s['m_e_d_Re'],0) != N_nm or np.size(s['m_e_d_Re'],1) != 2*N_sp:
        print(np.size(s['m_e_d_Re'],0), N_nm, np.size(s['m_e_d_Re'],1), 2*N_sp)
        raise Exception(r"wrong number of model coefficients")
    
    m_e_d_Re=np.reshape(s['m_e_d_Re'],N_coeff_nm,1)
    m_i_d_Re=np.reshape(s['m_i_d_Re'],N_coeff_nm,1)
    N_data=np.size(theta, 0)

    # CASE #1: above Sq currents
    
    if (min(rho) > rho_Sq):
        # calculate design matrices
        A_r_i_d,A_theta_i_dd,A_phi_i_dd=design_SHA_Sq_i_Re_v2.design_SHA_Sq_i_Re_v2(rho,theta_d,phi_d,t_season,t_mut,s['nmax'],s['mmax'],s['p_vec'],s['s_vec'])
        A_theta_i_d=np.zeros((N_coeff_nm,N_data))
        A_phi_i_d=np.zeros((N_coeff_nm,N_data))
        # calculate magnetic field
        B_r_1_tmp=np.dot(m_e_d_Re,A_r_i_d)
        B_theta_1_tmp=np.dot(m_e_d_Re,A_theta_i_dd)
        B_phi_1_tmp=np.dot(m_e_d_Re,A_phi_i_dd)
        B_r_2_tmp=np.dot(m_i_d_Re,A_r_i_d)
        B_theta_2_tmp=np.dot(m_i_d_Re,A_theta_i_dd)
        B_phi_2_tmp=np.dot(m_i_d_Re.T,A_phi_i_dd)
    # CASE #2: below Sq currents
    elif (max(rho) < rho_Sq):
            # calculate design matrices
            A_r_i_d,A_theta_i_dd,A_phi_i_dd=design_SHA_Sq_i_Re_v2.design_SHA_Sq_i_Re_v2(rho,theta_d,phi_d,t_season,t_mut,s['nmax'],s['mmax'],s['p_vec'],s['s_vec'])
            A_r_e_d,A_theta_e_dd,A_phi_e_dd=design_SHA_Sq_e_Re_v2.design_SHA_Sq_e_Re_v2(rho,theta_d,phi_d,t_season,t_mut,s['nmax'],s['mmax'],s['p_vec'],s['s_vec'])
            A_theta_i_d=np.zeros((N_coeff_nm,N_data))
            A_phi_i_d=np.zeros((N_coeff_nm,N_data))
            A_theta_e_d=np.zeros((N_coeff_nm,N_data))
            A_phi_e_d=np.zeros((N_coeff_nm,N_data))
            # calculate magnetic field
            B_r_1_tmp=np.dot(m_e_d_Re,A_r_e_d)
            B_theta_1_tmp=np.dot(m_e_d_Re,A_theta_e_dd)
            B_phi_1_tmp=np.dot(m_e_d_Re,A_phi_e_dd)
            B_r_2_tmp=np.dot(m_i_d_Re,A_r_i_d)
            B_theta_2_tmp=np.dot(m_i_d_Re,A_theta_i_dd)
            B_phi_2_tmp=np.dot(m_i_d_Re,A_phi_i_dd)
    # CASE #3: error
    else:
        raise Exception(r"data in both regions (below and above Sq currents)")
    
    #Rotate into geomagnetic frame
    B_theta_1_gg = np.zeros(N_data)
    B_phi_1_gg = np.zeros(N_data)
    B_theta_2_gg = np.zeros(N_data)
    B_phi_2_gg = np.zeros(N_data)
    for i in xrange(N_data):
        #get inverse of R
        tmp = R[i].transpose()
        B_theta_1_gg = tmp[0,0]*B_theta_1_tmp + tmp[0,1]*B_phi_1_tmp
        B_phi_1_gg = tmp[1,0]*B_theta_1_tmp + tmp[1,1]*B_phi_1_tmp
        B_theta_2_gg = tmp[0,0]*B_theta_2_tmp + tmp[0,1]*B_phi_2_tmp
        B_phi_2_gg = tmp[1,0]*B_theta_2_tmp + tmp[1,1]*B_phi_2_tmp
    # correct for F10.7 dependence
    w=(1 + s['N']*f107)
    B_1=np.vstack((B_r_1_tmp,B_theta_1_gg,B_phi_1_gg))*w
    B_2=np.vstack((B_r_2_tmp,B_theta_2_gg,B_phi_2_gg))*w
    return B_1, B_2
